Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(date 1482747518000)
+++ README.md	(date 1482747518000)
@@ -0,0 +1,140 @@
+# Battle simulator
+
+This is a test used to asses the candidates for the job position.
+
+## Introduction
+
+The focus of the test is to asses the maintainability and extendability of the code the candidate presents.
+
+The candidate is required to create a new branch on the repository and send an email once the task is completed.
+
+There are **NO** technology constraints nor strict deadlines but the estimated delivery time is 24h.
+
+The candidate should feel free to use any technology he/she feels comfortable in.
+
+If the candidate is picked for an interview, he/she will be required to provide an explanation on how the application could be extended with additional features.
+
+## Description
+
+This simulator is supposed to determine a battle outcome based on probability calculations.
+
+The Battlefield will support a configurable number of armies.
+Each army can have a configurable number of squads (>2).
+Each squad is consisted out of a number of units   (>5).
+
+Once the simulator is started all the army squads will start attacking each other until there is only one army left.
+
+## Units
+
+Each unit represents either a soldier or a vehicle maned by a predetermined number of soldiers.
+
+All units have the following properties:
+
+| Property | Range | Description |
+|----------|-------|-------------|
+| health   | % \[0-100\]  | Represents the health of the unit  |
+| recharge | \[100-2000\] | Represents the number of ms required to recharge the unit for an attack |
+
+### Soldiers
+
+Soldiers are units that have an additional property:
+
+| Property | Range | Description |
+|----------|-------|-------------|
+| experience | \[0-50\] | Represents the soldier experience |
+
+The **experience**  property is incremented after each successful attack, and is sed to calculate the attack success probability and the amount of damage inflicted
+
+Soldiers are considered active as long as they have any health.
+
+#### Attack
+
+Soldiers attack success probability is calculated:
+
+0.5 * (1 + health/100) * random(50 + experience, 100) / 100
+
+where **random(min, max)** returns a random number between min and max (inclusive)
+
+#### Damage
+
+The amount of damage a soldier can afflict is calculated as follows:
+
+0.05 + experience / 100
+
+### Vehicles
+
+A battle vehicle has these additional properties:
+
+| Property | Range | Description |
+|----------|-------|-------------|
+| operators | \[1-3\] | The number of soldiers required to operate the vehicle |
+
+The **recharge** property for a vehicle must be greater than 1000 (ms).
+
+The total health of a vehicle unit is represented as the average health of all it's operators and the health of the vehicle.
+
+A vehicle is considered active as long as it self has any health and there is an vehicle operator with any health.
+
+If the vehicle is destroyed, any remaining vehicle operator is considered as inactive (killed).
+
+#### Attack
+The Vehicle attack success probability is determined as follows:
+
+0.5 * (1 + vehicle.health / 100) * gavg(operators.attack_success)
+
+where **gavg** is the geometric average of the attack success of all the vehicle operators
+
+#### Damage
+
+The damage afflicted by a vehicle is calculated:
+
+0.1 + sum(operators.experience / 100)
+
+The total damage inflicted on the vehicle is distributed to the operators as follows:
+60% of the total damage is inflicted on the vehicle
+20% of the total damage is inflicted on a random vehicle operator
+The rest of the damage is inflicted evenly to the other operators (10% each)
+
+## Squads
+
+Squads are consisted out of a number of units (soldiers or vehicles), that behave as a coherent group.
+
+A squad is active as long as is contains an active unit.
+
+#### Attack
+
+The attack success probability of a squad is determined as the geometric average o the attack success probability of each member.
+
+#### Damage
+
+The damage received on a successful attack is distributed evenly to all squad members.
+The damage inflicted on a successful attack is the accumulation of the damage inflicted by each squad member.
+
+## Attacking & Defending
+
+Each time a squad attacks it must choose a target squad, depending on the chosen strategy:
+
+| Strategy | Description |
+|----------|-------------|
+| random    | attack any random squad               |
+| weakest   | attack the weakest opposing squad     |
+| strongest | attack the strongest opposing squad   |
+
+Once the target is determined both the attacking and defending squads calculate their attack probability success and the squad with the highest probability wins.
+If the attacking squad wins, damage is dealt to the defending side.
+If the attacking squad loses, no damage is dealt to either side.
+
+## Configuration
+
+The following constraints should be configurable:
+
+- The number of armies: 2 <= n
+- The choice of attack strategy per army: random|weakest|strongest
+- The number of squads per army: 2 <= n
+- The number of units per squad: 5 <= n <= 10
+
+## UI
+
+There are no UI requirements for this task
+
+
Index: lib/army.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/army.js	(date 1482613930000)
+++ lib/army.js	(date 1482747956000)
@@ -1,3 +1,5 @@
+'use strict';
+
 const _ = require('lodash');
 const Squad = require('./squad');

@@ -10,10 +12,9 @@
 	 */
 	static createArmies(armies, simulator) {
 		const instances = [];
-		if (armies.length < 2) {
-			throw new Error('At least 2 armies need to be specified');
-		}
-
+    if (armies.length < 2) {
+      throw new Error('At least 2 armies need to be specified');
+    }
 		armies.forEach(army => {
 			instances.push(new Army(army, simulator));
 		});
@@ -27,11 +28,13 @@
 	 * @param {Simulator} simulator Simulator instance
 	 */
 	constructor(army, simulator) {
+		// TODO@dvs: Why propagating the simulator instance?
 		console.log(`[INIT] Initializing army '${army.name}'`);
 		this.name = army.name;
 		this.squads = Squad.createSquads(army.squads, this, simulator);
 	}

+
 	/**
 	 * Get active squads
 	 * @returns {Array} Active squads
Index: lib/unit.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/unit.js	(date 1482613930000)
+++ lib/unit.js	(date 1482751130000)
@@ -1,3 +1,5 @@
+'use strict';
+
 const _ = require('lodash');

 class Unit {
@@ -6,9 +8,13 @@
 	 * @param {Squad} squad Squad instance
 	 */
 	constructor(squad) {
-		this.recharge = _.random(100, 2000);
+    // TODO@dvs: Shouldn't the _.random be called by the invoker of the constructor? _.clamp?
+    this.recharge = _.random(100, 2000);
 		this.health = 100;
+		// TODO@dvs: Same issue with a "child" referencing it's "parent"?
 		this.squad = squad;
+    // TODO@dvs: Why not: this.startRecharging()? If the subclass doesn't implement its the unit will not work.
+    // TODO@dvs: Why having this.startRecharging() in any constructor? Does every unit start fighting as soon as created :D More on that later.
 	}

 	/**
@@ -45,6 +51,7 @@
 	 * @param {number} amount Damage amount
 	 */
 	receiveDamage(amount) {
+    // TODO@dvs: Should have used this.getHealth().
 		this.setHealth(this.health - amount);
 		// console.log(`[DAMAGE] Unit from squad ${this.squad.squadIndex} from army '${this.squad.army.name}' received ${amount} damage. Health left ${this.getHealth()}`);
 	}
@@ -62,6 +69,7 @@
 	 */
 	startRecharging() {
 		this.rechargeTimeout = setTimeout(() => {
+      // TODO@dvs: It seems that a Unit doesn't implement levelUp, but fortunately the ones that inherited it do. Dangerous!
 			this.unitReady();
 		}, this.recharge);
 	}
Index: lib/squad.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/squad.js	(date 1482613930000)
+++ lib/squad.js	(date 1482753578000)
@@ -1,10 +1,12 @@
+'use strict';
+
 const _ = require('lodash');
 const gmean = require('compute-gmean');
 const Soldier = require('./unit/soldier');
 const Vehicle = require('./unit/vehicle');

 // Unit types that will be picked randomly
-const Units = [Soldier, Vehicle]; // Could be made programatically
+const Units = [Soldier, Vehicle]; // Could be made dynamic

 class Squad {
 	/**
@@ -37,11 +39,14 @@
 	 * @param {Simulator} simulator Simulator instance
 	 */
 	constructor(squad, army, squadIndex, simulator) {
+		// TODO@dvs: The strategy should originate from the squad's army @see(README.md#132: "strategy per army")
 		this.squad = squad;
 		this.squadIndex = squadIndex;
+		// TODO@dvs: Why did you allow the "child" structure to have a reference to it's "parent"?
 		this.army = army;
 		this.ready = 0;
-		this.simulator = simulator;
+    // TODO@dvs: Same question with the "child" referencing it's "parent"?
+    this.simulator = simulator;

 		console.log(`[INIT] Initializing squad ${squadIndex}`);
 		if (squad.units < 5) {
@@ -52,13 +57,16 @@
 			throw new Error('Squad can have maximum 10 units');
 		}

+		// TODO@dvs: Uff. Adding other strategies is out of the question I see!
 		if (['weakest', 'strongest', 'random'].indexOf(squad.strategy) < 0) {
 			throw new Error('Unsupported strategy specified');
 		}

 		this.units = [];

+		// TODO@dvs: Not that it matters, but what happened with "lodash", like: _.each(_.range(squad.units), () => {
 		for (let i = 0; i < squad.units; i++) {
+		  // TODO@dvs: Why not have a Unit.createUnits: factory method? _.sample within a constructor?
 			// Pick random unit type
 			const Unit = _.sample(Units);
 			this.units.push(new (Unit)(this));
@@ -78,6 +86,7 @@
 	 * @returns {number} Squad attack probability, geometric average of all units attack probability
 	 */
 	getAttackProbability() {
+		// TODO@dvs: It seems that a Unit doesn't implement getAttackProbability, but fortunately the ones that inherited it do. Dangerous!
 		return gmean(this.getActiveUnits().map(unit => unit.getAttackProbability()));
 	}

@@ -86,6 +95,7 @@
 	 * @returns {number} Squad damage, sum of all units damage
 	 */
 	getDamage() {
+    // TODO@dvs: It seems that a Unit doesn't implement getDamage, but fortunately the ones that inherited it do. Dangerous!
 		return _.sumBy(this.getActiveUnits(), unit => unit.getDamage());
 	}

@@ -109,6 +119,7 @@
 	 * Level up, propagates to all units
 	 */
 	levelUp() {
+    // TODO@dvs: It seems that a Unit doesn't implement levelUp, but fortunately the ones that inherited it do. Dangerous!
 		this.getActiveUnits().forEach(unit => {
 			unit.levelUp();
 		});
@@ -128,6 +139,7 @@
 			console.log(`[RECHARGE] Squad ${this.squadIndex} from army '${this.army.name}' is ready`);
 			this.attack();
 		}
+		// TODO@dvs:! You can not guarantee which unit called the method. Not sure if 2 timeouts of a single unit called the squads.unitReady
 	}

 	/**
@@ -147,8 +159,9 @@
 		case 'random':
 			squadToAttack = this.simulator.getRandomSquad(this.army);
 			break;
-		default:
+		// default:
 		}
+		// TODO@dvs: Why not create a Strategy class and avoid switches and such? Or at least encapsulate in a getStrategy method?

 		// Get attacker and defender attack probabilities
 		const attackerProbability = this.getAttackProbability();
@@ -167,9 +180,10 @@

 		const activeArmies = this.simulator.getActiveArmies();
 		if (activeArmies.length === 1) {
-			// Army won
+      // Army won
 			console.log(`[END] Army '${activeArmies[0].name}' won the battle!`);
 			process.exit(0);
+      // TODO@dvs:! Wow. process.exit? A bit harsh on the developer that is supposed to use this class?
 		} else {
 			// Army did not won yet, recharge all units
 			this.getActiveUnits().forEach(unit => {
Index: lib/simulator.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/simulator.js	(date 1482613930000)
+++ lib/simulator.js	(date 1482748644000)
@@ -1,3 +1,5 @@
+'use strict';
+
 const _ = require('lodash');
 const Army = require('./army');

Index: lib/unit/soldier.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/unit/soldier.js	(date 1482613930000)
+++ lib/unit/soldier.js	(date 1482751130000)
@@ -1,3 +1,5 @@
+'use strict';
+
 const _ = require('lodash');
 const Unit = require('../unit');

@@ -10,8 +12,10 @@
 		super(squad);
 		this.experience = 0;
 		console.log('[INIT] Creating soldier');
-		this.startRecharging();
-	}
+    // TODO@dvs: Why is this not mentioned in the parent class?
+    this.startRecharging();
+    // TODO@dvs: Why are we mixing the bootstrap phase (instantiating the simulation elements) with the runtime phase (running the simulation)?
+  }

 	/**
 	 * Level up
@@ -52,6 +56,7 @@
 	 * Unit is recharged, notify the parent squad/vehicle
 	 */
 	unitReady() {
+		// TODO@dvs: Why would the "child" instance notify it's "parent" with a function call? Aren't events used for that?
 		this.squad.unitReady();
 		// console.log(`[RECHARGE] Soldier from squad ${this.squad.squadIndex} and army '${this.squad.army.name}' is ready`);
 	}
Index: lib/unit/vehicle.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/unit/vehicle.js	(date 1482613930000)
+++ lib/unit/vehicle.js	(date 1482753578000)
@@ -1,3 +1,5 @@
+'use strict';
+
 const _ = require('lodash');
 const Unit = require('../unit');
 const Soldier = require('./soldier');
@@ -10,11 +12,13 @@
 	 */
 	constructor(squad) {
 		super(squad);
-		this.recharge = _.random(1000, 2000);
+    // TODO@dvs: Same as with Unit about the _.random thing? Including that now after super(), _.random has been called twice.
+    this.recharge = _.random(1000, 2000);
 		this.army = squad.army;
 		this.squadIndex = squad.squadIndex;
 		this.operators = [];

+		// TODO@dvs: Why not in a Soldier.createSoldiers. Again with the _.random in a constructor? Or was it _.sample
 		const operators = _.random(1, 3);
 		console.log(`[INIT] Creating vehicle with ${operators} operators`);
 		for (let i = 0; i < operators; i++) {
@@ -22,8 +26,11 @@
 			this.operators.push(new Soldier(this));
 		}

-		this.ready = 0;
+    // TODO@dvs: What is this.ready, and why is it not mentioned in the parent class?
+    this.ready = 0;
+    // TODO@dvs: Why is this not mentioned in the parent class?
 		this.startRecharging();
+    // TODO@dvs: Why are we mixing the bootstrap phase (instantiating the simulation elements) with the runtime phase (running the simulation)?
 	}

 	/**
@@ -31,7 +38,8 @@
 	 * @returns {number} Vehicle health
 	 */
 	getHealth() {
-		return _.mean([...this.getActiveOperators().map(operator => operator.getHealth()), this.health]);
+    // TODO@dvs: Should have used this.getHealth() instead of this.health
+    return _.mean(this.getActiveOperators().map(operator => operator.getHealth()).concat([this.health]));
 	}

 	/**
@@ -74,12 +82,14 @@
 		const activeOperators = this.getActiveOperators();
 		const randomOperator = _.sample(activeOperators);

+    // TODO@dvs: Why not use super.getHealth() instead of accessing the property directly?
 		this.setHealth(this.health - (amount * 0.6));

 		// Random operator should receive 20% of the damage. If that's the only operator, he'll take the rest of the damage
 		randomOperator.receiveDamage(amount * (activeOperators.length === 1 ? 0.4 : 0.2));
 		_.without(activeOperators, randomOperator).forEach(operator => {
-			// The task says evenly and 10% each, which is not always the case. I distributed the rest of the damage evently to remaining operators
+			// The task says evenly and 10% each, which is not always the case. I distributed the rest of the damage evenly to remaining operators
+			// TODO@dvs: You did the right thing. The 10% was just an example when all the operators are active.
 			operator.receiveDamage((amount * 0.2) / (activeOperators.length - 1));
 		}, this);

@@ -102,7 +112,9 @@
 		// Count ready units and compare to the operator count plus vehicle
 		this.ready++;
 		if (this.ready === this.getActiveOperators().length + 1) {
+			// TODO@dvs: Aren't we missing here a little: this.ready = 0; // Otherwise the vehicle will never be "ready" again after the first time. Like nuns.
 			// console.log(`[RECHARGE] Vehicle from squad ${this.squad.squadIndex} and army '${this.squad.army.name}' is ready`);
+      // TODO@dvs: Why would the "child" instance notify it's "parent" with a function call? Aren't events used for that?
 			this.squad.unitReady();
 		} else {
 			// console.log(`[RECHARGE] Vehicle operator from squad ${this.squad.squadIndex} and army '${this.squad.army.name}' is ready`);
